#+TITLE:	Exercício 6.30 (Papadimitriou)
#+AUTHOR:	Alice Duarte Scarpa, Bruno Lucian Costa
#+EMAIL:	alicescarpa@gmail.com, bruno.lucian.costa@gmail.com
#+DATE:		2015-06-23
#+OPTIONS: tex:t
#+OPTIONS: toc:nil
#+STARTUP: showall
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LaTeX_HEADER: \usemintedstyle{perldoc}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usetikzlibrary{decorations.markings}
#+LaTeX_HEADER: \tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
#+LaTeX_HEADER: \newcommand{\vertex}{\node[vertex]}

* Enunciado

  \textit{Reconstruindo árvores filogenéticas pelo método da máxima parcimônia}

  Uma árvore filogenética é uma árvore em que as folhas são espécies
  diferentes, cuja raiz é o ancestral comum de tais espécies e cujos
  galhos representam eventos de especiação.

  Queremos achar:

    * Uma árvore (binária) evolucionária com as espécies dadas
    * Para cada nó interno uma string de comprimento $k$ com a
      sequência genética daquele ancestral.


  Dada uma árvore acompanhada de uma string $s(u) \in \{A, C, G, T\}^k$ para
  cada nó $u \in V(T)$, podemos atribuir uma nota usando o método da
  máxima parcimônia, que diz que menos mutações são mais prováveis:
  \[ \mathrm{nota}(T) = \sum_{(u,v) \in E(T)} (\text{número de posições em que }s(u)\text{ e }s(v)\text{ diferem}). \]

  Achar a árvore com nota mais baixa é um problema difícil. Aqui vamos
  considerar um problema menor: Dada a estrutura da árvore, achar as
  sequências genéticas $s(u)$ para os nós internos que dêem a nota mais
  baixa.

   Um exemplo com $k = 4$ e $n = 5$:

   [[http://github.com/adusca/FGV-EDA/6_30/tree.png][file:tree.png]]

    1. Ache uma reconstrução para o exemplo seguindo o método da
      máxima parcimônia.
    2. Dê um algoritmo eficiente para essa tarefa.

* Solução

A nota final de uma árvore é a soma da nota de cada letra. Podemos
calcular a resposta para cada letra independentemente e depois
concatenar as respostas para obter a árvore final.

Nós vamos usar um algoritmo de programação dinâmica para encontrar o
valor das folhas intermediárias em uma árvore $P$ em que cada
folha tem valor A, G, T ou C

Vamos representar a nossa árvore como um objeto:
#+Name: estrutura_de_dados
#+BEGIN_SRC python
class Arvore:
    def __init__(self, pai):
        self.filhos = []
        self.label = ""
        self.pai = pai

#+END_SRC

Vamos computar $melhor nota[v][\ell]$ como a melhor maneira de preencher os nós
da sub-árvore enraizada em $v$, dado que o pai de $v$ tem valor \ell.

TODO: justificar a inicializacao
#+NAME: inicializando
#+BEGIN_SRC python
valor = {}
melhor_nota = {}
#+END_SRC

Vamos computar $melhor nota$ de baixo para cima. Então, o caso base
para esse algoritmo é a resposta para as folhas, isso é, $melhor
nota[\mathrm{folha}][\ell]$.

Uma sub-árvore que contém apenas uma folha e seu pai vai ter
$\mathrm{nota} = 0$ se a folha e o pai tiverem ambos o mesmo valor (A,
G, T ou C) ou $\mathrm{nota} = 1$, se os dois tiverem valores diferentes:

\[melhor nota[\mathrm{folha}][\ell] = \begin{cases}0 \text{ se } \mathrm{valor}[\mathrm{folha}] = \ell \\
                                                   1 \text{ caso contrário}\end{cases}\]

Podemos então preencher as folhas:
#+NAME: caso_base
#+BEGIN_SRC python
#TODO: preencher as folhas
#+END_SRC

Tendo o caso base, podemos computar $melhor nota[v][\ell]$ assumindo que $melhor nota[w][\ell]$ já foi computado para
todo $w$ filho de $v$ e $\ell \in \{A, G, T, C\}$.

TODO: explicar em algum lugar que a raiz é especial

A nota da sub-árvore quando o valor de $v$ é igual a $m$ é:

\[[\ell \neq m] + \sum_{w \text{ filho de }v} melhor nota[w][m]\]

Onde \[[\ell \neq m] =  \begin{cases} 0 \text{ se } m = \ell \\
                                     1 \text{ caso contrário}\end{cases}\]

Queremos escolher um valor $m \in \{A, G, T, C\}$ para $v$
que minimize a nota final da sub-árvore. Então:

\[melhor nota[v][\ell] = \min_{m \in \{A, G, T, C\}}  \left([\ell \neq m] + \sum_{w \text{ filho de }v} melhor nota[w][m]\right)\]

#+Name: preenchendo_melhor_nota
#+BEGIN_SRC python
# TODO: preencher os outros vértices (exceto a raiz)
#+END_SRC

Após computarmos $melhor nota[v][\ell]$ para todos os vértices exceto a raiz
podemos encontrar a nota da árvore como o mínimo entre os possíveis
valores para a raiz:

\[ \min_{\ell \in \{A, G, T, C\}} \sum_{v \text{ filho da raiz}} melhor nota[v][\ell]\]

#+Name: resposta
#+BEGIN_SRC python

#+END_SRC

* Dados reais

** Formato Newick

Um formato muito usado para árvores em bioinformática é o formato
Newick. Assim como LISP, ele usa o fato de que parenteses podem ser
usados para especificar uma árvore.

TODO: especificar o formato, referência do formato

*** Parseando o formato Newick

O primeiro passo é notar que (gato, rato) é equivalente a
((gato)(rato)), então podemos transformar uma estrutura com vírgulas
em uma estrutura que só contém parênteses.

TODO: explicar o código
#+NAME: parseando_newick
#+BEGIN_SRC python
def parseia_newick(string):
    string = string.replace(',', ')(').replace(';', '')

    em_construcao = collections.deque()
    em_construcao.append(Arvore(None))

    for ch in string:
        if ch == '(':
            pai_atual = em_construcao[-1]
            filho_novo = Arvore(pai_atual)
            pai_atual.filhos.append(filho_novo)
            em_construcao.append(filho_novo)
        elif ch == ')':
            em_construcao.pop()
        else:
            em_construcao[-1].label += ch

    assert len(em_construcao) == 1
    return em_construcao[0]
#+END_SRC


*** Separando e concatenando árvores

As árvores no nosso algoritmo só tem uma letra por nó, mas nós
recebemos apenas uma árvore com toda a string de DNA.

Precisamos de um método para capaz de criar uma árvore para cada
carácter. A seguinte DFS cria a árvore das i-ésimas letras:
#+NAME: separa_arvore
#+BEGIN_SRC python
def separa_arvore(indice, origem):
    copia_origem = Arvore(None)
    if len(origem.label):
        copia_origem.label = origem.label[indice]

    for filho in origem.filhos:
        copia_filho = separa_arvore(indice, filho)
        copia_filho.pai = copia_origem
        copia_origem.filhos.append(copia_filho)

    return copia_origem
#+END_SRC

Depois de rodar o algoritmo, vamos querer juntar as árvores para encontrar
os valores dos nós intermediários. Podemos fazer isso com uma DFS e ~reduce~.
#+NAME: juntando_arvores
#+BEGIN_SRC python
def concatena_arvores(arvores):
    fusao = Arvore(None)
    fusao.label = reduce(lambda string, arv: string + arv.label, arvores, "")

    for i in xrange(len(arvores[0].filhos)):
        fusao_filho = concatena_arvores(map(lambda arvore: arvore.filhos[i],
                                            arvores))
        fusao_filho.pai = fusao
        fusao.filhos.append(fusao_filho)

    return fusao
#+END_SRC
** Rosalind

Obtemos os dados do Rosalind, TODO: explicar o Rosalind.

Rosalind MULT, GLOB, EDTA, PERM, EDIT, LCSQ,
CSTR, CTBL, NWCK, SSET, MRNA, KMP, PROB
SSEQ, SPLC, LCSM

** Rodando o algoritmo com dados reais

* Extensões

Ao fazer esse exercício, notamos que a árvore já é uma entrada do problema.
Como é possível obter a árvore de menor valor a partir das espécies

Esse problema é NP-completo [TODO: colocar referência] e o melhor
algoritmo conhecido é [TODO]
