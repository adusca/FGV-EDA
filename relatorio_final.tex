% Created 2015-06-20 Sáb 13:15
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{minted}
\usemintedstyle{perldoc}
\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
\newcommand{\vertex}{\node[vertex]}
\usemintedstyle{perldoc}
\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
\newcommand{\vertex}{\node[vertex]}
\usemintedstyle{perldoc}
\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
\newcommand{\vertex}{\node[vertex]}
\usemintedstyle{perldoc}
\usepackage{tikz}
\hyphenation{es-co-lhi-dos}
\usepackage[table]{xcolor}
\usetikzlibrary{decorations.markings}
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
\newcommand{\vertex}{\node[vertex]}
\usemintedstyle{perldoc}
\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
\newcommand{\vertex}{\node[vertex]}
\usemintedstyle{perldoc}
\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
\newcommand{\vertex}{\node[vertex]}
\author{Alice Duarte Scarpa, Bruno Lucian Costa}
\date{2015-06-23}
\title{Trabalho de Estrutura de Dados e Algoritmos}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.4.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle

\section{Exercício 6.30 (Papadimitriou)}
\label{sec-1}

\subsection{Enunciado}
\label{sec-1-1}

\textit{Reconstruindo árvores filogenéticas pelo método da máxima parcimônia}

Uma árvore filogenética é uma árvore em que as folhas são espécies
diferentes, cuja raiz é o ancestral comum de tais espécies e cujos
galhos representam eventos de especiação.

Queremos achar:

\begin{itemize}
\item Uma árvore (binária) evolucionária com as espécies dadas
\item Para cada nó interno uma string de comprimento $k$ com a
sequência genética daquele ancestral.
\end{itemize}


Dada uma árvore acompanhada de uma string $s(u) \in \{A, C, G, T\}^k$ para
cada nó $u \in V(T)$, podemos atribuir uma nota usando o método da
máxima parcimônia, que diz que menos mutações são mais prováveis:
\[ \mathrm{nota}(T) = \sum_{(u,v) \in E(T)} (\text{número de posições em que }s(u)\text{ e }s(v)\text{ diferem}). \]

Achar a árvore com nota mais baixa é um problema difícil. Aqui vamos
considerar um problema menor: Dada a estrutura da árvore, achar as
sequências genéticas $s(u)$ para os nós internos que dêem a nota mais
baixa.

Um exemplo com $k = 4$ e $n = 5$:

\href{http://github.com/adusca/FGV-EDA/6_30/tree.png}{\includegraphics[width=.9\linewidth]{tree.png}}

\begin{enumerate}
\item Ache uma reconstrução para o exemplo seguindo o método da
máxima parcimônia.
\item Dê um algoritmo eficiente para essa tarefa.
\end{enumerate}

\subsection{Solução}
\label{sec-1-2}

Como o valor só depende TODO.

Vamos calcular a resposta para cada letra independentemente e depois
concatenar as respostas para obter a árvore final.

Nós vamos usar um algoritmo de programação dinâmica para encontrar o
valor das folhas intermediárias em uma árvore $P$ em que cada
folha tem valor A, G, T ou C

TODO: estrutura de dados para representar a árvore.
\begin{minted}[]{python}
class Arvore:
    def __init__(self, pai):
        self.filhos = []
        self.label = ""
        self.pai = pai

# Colocar aqui uma estrutura de dados para a arvore
\end{minted}

TODO: achar um nome melhor para ans

Vamos computar $ans[v][\ell]$ como a melhor maneira de preencher os nós
da sub-árvore enraizada em $v$, dado que o pai de $v$ tem valor $\ell$.

TODO: justificar a inicializacao
\begin{minted}[]{python}
valor = {}
ans = {}
\end{minted}

Vamos computar $ans$ de baixo para cima. Então, o caso base para esse algoritmo
é a resposta para as folhas, isso é, $ans[\mathrm{folha}][\ell]$.

Uma sub-árvore que contém apenas uma folha e seu pai vai ter
$\mathrm{nota} = 0$ se a folha e o pai tiverem ambos o mesmo valor (A,
G, T ou C) ou $\mathrm{nota} = 1$, se os dois tiverem valores diferentes:

\[ans[\mathrm{folha}][\ell] = \begin{cases}0 \text{ se } \mathrm{valor}[\mathrm{folha}] = \ell \\
                                                     1 \text{ caso contrário}\end{cases}\]

Podemos então preencher as folhas:
\begin{minted}[]{python}
#TODO: preencher as folhas
\end{minted}

Tendo o caso base, podemos computar $ans[v][\ell]$ assumindo que $ans[w][\ell]$ já foi computado para
todo $w$ filho de $v$ e $\ell \in \{A, G, T, C\}$.

TODO: explicar em algum lugar que a raiz é especial

A nota da sub-árvore quando o valor de $v$ é igual a $m$ é:

\[[\ell \neq m] + \sum_{w \text{ filho de }v} ans[w][m]\]

Onde \[[\ell \neq m] =  \begin{cases} 0 \text{ se } m = \ell \\
                                     1 \text{ caso contrário}\end{cases}\]

Queremos escolher um valor $m \in \{A, G, T, C\}$ para $v$
que minimize a nota final da sub-árvore. Então:

\[ans[v][\ell] = \min_{m \in \{A, G, T, C\}}  \left([\ell \neq m] + \sum_{w \text{ filho de }v} ans[w][m]\right)\]

\begin{minted}[]{python}
# TODO: preencher os outros vértices (exceto a raiz)
\end{minted}

Após computarmos $ans[v][\ell]$ para todos os vértices exceto a raiz
podemos encontrar a nota da árvore como o mínimo entre os possíveis
valores para a raiz:

\[ \min_{\ell \in \{A, G, T, C\}} \sum_{v \text{ filho da raiz}} ans[v][\ell]\]

\subsection{Dados reais}
\label{sec-1-3}

\subsubsection{Formato Newick}
\label{sec-1-3-1}

Um formato muito usado para árvores em bioinformática é o formato
Newick. Assim como LISP, ele usa o fato de que parenteses podem ser
usados para especificar uma árvore.

TODO: especificar o formato, referência do formato

\begin{enumerate}
\item Parseando o formato Newick
\label{sec-1-3-1-1}
\end{enumerate}

\subsubsection{Rosalind}
\label{sec-1-3-2}

Obtemos os dados do Rosalind, TODO: explicar o Rosalind.

Rosalind MULT, GLOB, EDTA, PERM, EDIT, LCSQ,
CSTR, CTBL, NWCK, SSET, MRNA, KMP, PROB
SSEQ, SPLC, LCSM

\subsubsection{Rodando o algoritmo com dados reais}
\label{sec-1-3-3}

\subsection{Extensões}
\label{sec-1-4}

Ao fazer esse exercício, notamos que a árvore já é uma entrada do problema.
Como é possível obter a árvore de menor valor a partir das espécies

Esse problema é NP-completo [TODO: colocar referência] e o melhor
algoritmo conhecido é [TODO]

\section{Exercício 6.3 (Papadimitriou)}
\label{sec-2}

\subsection{Enunciado}
\label{sec-2-1}

O Yuckdonald's está considerando abrir uma cadeia de restaurantes em
Quaint Valley Highway (QVG). Os $n$ locais possíveis estão em uma
linha reta, e as distâncias desses locais até o começo da QVG são, em
milhas e em ordem crescente, $m_1, m_2, \ldots, m_n$. As restrições
são as seguintes:

\begin{itemize}
\item Em cada local, o Yuckdonald's pode abrir no máximo um
restaurante. O lucro esperado ao abrir um restaurante no local
$i$ é $p_i$, onde $p_i > 0$ e $i = 1, 2, \ldots, n$.
\item Quaisquer dois restaurantes devem estar a pelo menos $k$
  milhas de distância, onde $k$ é um inteiro positivo.
\end{itemize}

Dê um algoritmo eficiente para computar o maior lucro total
esperado, sujeito às restrições acima.

\section{Exercício 7.28 (Tardos)}
\label{sec-3}

\subsection{Enunciado}
\label{sec-3-1}

Um grupo de estudantes está escrevendo um módulo para preparar
cronogramas de monitoria. O protótipo inicial deles funciona do
seguinte modo: O cronograma é semanal, de modo que podemos nos focar
em uma única semana.

\begin{itemize}
\item O administrador do curso escolhe um conjunto de $k$
intervalos disjuntos de uma hora de duração $I_1, I_2, \ldots,
      I_k$, nos quais seria possível que monitores dessem suas
monitorias; o cronograma final consistirá de um subconjunto de
alguns (mas geralmente não todos) esses intervalos.
\item Cada monitor então entra com seu horário semanal, informando
as horas em que ele está disponível para monitorias.
\item O administrador então especifica, para parâmetros $a$, $b$ e
$c$, que cada monitor deve dar entre $a$ e $b$ horas de
monitoria por semana, e que um total de $c$ horas de monitoria
deve ser dado semanalmente.
\end{itemize}

O problema é escolher um subconjunto dos horários (intervalos) e
atribuir um monitor a cada um desses horários, respeitando a
disponibilidade dos monitores e as restrições impostas pelo
administrador.


a) Dê um algoritmo polinomial que ou constrói um cronograma
   válido de horas de monitoria (especificando que monitor cobre
   quais horários) ou informa que não há cronograma válido.


b) O algoritmo acima tornou-se popular, e surgiu a vontade de
   controlar também a densidade das monitorias: dado números $d_i$,
   com $i$ entre $1$ e $5$, queremos um cronograma com pelo menos
   $d_i$ horários de monitoria no dia da semana $i$. Dê um
   algoritmo polinomial para resolver o problema com essa restrição
   adicional.


\subsection{Introdução}
\label{sec-3-2}

Queremos modelar esse problema como um problema de fluxo. Para isso
vamos começar com algumas definições de fluxo.

\subsubsection{Definições}
\label{sec-3-2-1}

Uma rede de fluxo é um grafo direcionado $G =
(V, E)$ com as seguintes propriedades:
\begin{itemize}
\item Existe um único vértice \textit{fonte} $s \in V$. Nenhuma aresta entra em $s$.
\item A cada aresta $e$ está associada uma capacidade inteira $c_e$ e
uma demanda $d_e$ tal que $c_e \geq d_e \geq 0$.
\item Existe um único vértice \textit{dreno} $t \in V$. Nenhuma aresta sai de $t$.
\end{itemize}

Um fluxo $f$ de $s$ a $t$ é uma função $f \colon E \to R^+$ que associa a cada
aresta $e$ um valor real não-negativo $f(e)$ tal que:

\begin{enumerate}
\item $\forall e \in E, d_e \leq f(e) \leq c_e$
\item Para todo nó $v \not\in \{s,t\}$:
\[ \sum_{e \text{ chegando em } v} f(e) = \sum_{e \text{ saindo de } v} f(e) \]
\end{enumerate}

$f(e)$ representa o fluxo que vai passar pela aresta $e$. O valor de
um fluxo é o total que parte da fonte $s$, isso é:

$$\label{valor_fluxo} \mathrm{Valor}(f) = \sum_{e \text{ saindo de } s} f(e) $$

TODO: definir circulação
\subsubsection{Representação}
\label{sec-3-2-2}

Podemos usar programação orientada a objetos [TODO: colocar alguma
referência de OOP] para nos ajudar na representação da rede de fluxo,
simplificando o algoritmo.

TODO: explicar a parte de já construir o
grafo reverso.

Vamos usar uma classe para representar arestas. Uma aresta é
inicializada com as propriedades: vértice de origem, vértice de
destino, capacidade e demanda.

TODO: explicar reversa e original
\begin{minted}[]{python}
class Aresta():
    def __init__(self, origem, destino, capacidade, demanda):
        self.origem = origem
        self.destino = destino
        self.capacidade = capacidade
        self.demanda = demanda
        self.reversa = None
        self.original = True
\end{minted}

Agora que temos a classe Aresta, vamos usá-la para auxiliar na
representação de uma rede de fluxo também como objeto.

Uma rede de fluxo tem duas propriedades: adjacências, um dicionário
que mapeia cada vértice às arestas que saem dele e fluxo TODO: explicar isso

O construtor da classe inicializa as duas propriedades como dicionários vazios.

Vamos precisar dos seguintes métodos na nossa classe RedeDeFluxo:

\begin{itemize}
\item \verb~novo_vertice(v)~: Adiciona o vértice v à rede
\item \verb~nova_aresta(origem, destino, capacidade)~: Adiciona uma nova aresta a
rede. Também cria a aresta reversa.
\item \verb~novo_fluxo(f, e)~: Adiciona um fluxo $f$ à aresta $e$
\item \verb~encontra_arestas(v)~: Retorna as arestas que partem do vértice $v$
\item \verb~valor_do_fluxo(fonte)~: Encontra o valor do fluxo, como definido em \eqref{valor_fluxo}.
\end{itemize}

\begin{minted}[]{python}
class RedeDeFluxo():
    def __init__(self):
        self.adj = collections.OrderedDict()
        self.fluxo = {}

    def novo_vertice(self, v):
        self.adj[v] = []

    def nova_aresta(self, origem, destino, capacidade, demanda):
        aresta = Aresta(origem, destino, capacidade, demanda)
        self.adj[origem].append(aresta)

        # Criando a aresta reversa
        aresta_reversa = Aresta(destino, origem, 0, -demanda)
        self.adj[destino].append(aresta_reversa)
        aresta_reversa.original = False

        # Marcando aresta e aresta_reversa como reversas uma da outra
        aresta.reversa = aresta_reversa
        aresta_reversa.reversa = aresta

    def novo_fluxo(self, e, f):
        self.fluxo[e] = f

    def encontra_arestas(self, v):
        return self.adj[v]

    def valor_do_fluxo(self, fonte):
        valor = 0
        for aresta in self.encontra_arestas(fonte):
            valor += self.fluxo[aresta]
        return valor
\end{minted}

\subsection{Modelando o problema com fluxos}
\label{sec-3-3}

Os dois itens do problema podem ser reduzidos a encontrar um fluxo
válido em uma rede usando construções semelhantes.

Para o item a), construimos o grafo da seguinte forma:

\begin{itemize}
\item Criamos um vértice $s$ representando a fonte e um vértice $t$
  representando o dreno
\item Para cada intervalo $I_i \in I_1, I_2, \ldots, I_k$ escolhido pelo
administrador, criamos um vértice $I_i$ e uma aresta $(s, I_i)$
capacidade 1 e demanda 0
\item Para cada monitor $T_i \in T_1, T_2, \ldots, T_m$ criamos um vértice
$T_i$. Se o monitor está disponível para dar monitoria no intervalo
$I_j$ criamos uma aresta de $(I_j, T_i)$ de demanda 0 e
capacidade 1. Para cada monitor também criamos uma aresta
$(T_i, t)$ de demanda $a$ e capacidade $b$.
\item Para garantir que a solução final terá exatamente $c$ horas de
monitoria, criamos uma nova fonte $s'$ e uma aresta $(s', s)$
com demanda e capacidade $c$.
\end{itemize}

TODO: argumentar que soluções para esse problema são equivalentes a
soluções do problema original

O caso com 3 intervalos e 2 monitores (A e B) em que o monitor A está
disponível nos intervalos 1 e 2 e o monitor B está disponível nos
horários 1 e 3 está representado abaixo. Os rótulos
das arestas são da forma demanda/capacidade. As
arestas sem rótulo tem demanda 0 e capacidade 1.

TODO: circulação
\[\begin{tikzpicture}[x=0.25\textwidth,
    every edge/.style={
        draw,
        postaction={decorate,
                    decoration={markings,mark=at position 1 with {\arrow[line width = 0.5mm]{stealth}}}
                   }
        }
]
\vertex (fonte') at (0,3) [label=above:$\textit{s}$] {};
\vertex (fonte) at (-0.5,3) [label=above:$s'$] {};
\vertex (I1) at (1,5) [label=above:$I_1$] {};
\vertex (I2) at (1,3) [label=above:$I_2$] {};
\vertex (I3) at (1,1) [label=above:$I_3$] {};
\vertex (A) at (2,4) [label=above:$A$] {};
\vertex (B) at (2,2) [label=above:$B$] {};
\vertex (dreno) at (3,3) [label=above:$t$] {};
\path
(fonte) edge node [above] {$c/c$} (fonte')
(fonte') edge (I1)
(fonte') edge (I2)
(fonte') edge (I3)
(I1) edge (A)
(I1) edge (B)
(I2) edge (B)
(I3) edge (A)
(A) edge node [above] {$a/b$} (dreno)
(B) edge node [above] {$a/b$} (dreno)
;
\end{tikzpicture}\]

A única diferença na construção do item b é que, ao invés de ligarmos
$s$ diretamente aos intervalos de monitoria, ligamos $s$ a cada dia da
semana i com demanda $d_i$ e capacidade $c$ e depois
criamos uma aresta com demanda 0 e capacidade 1 de
cada dia da semana para os intervalos que são naquele dia.

TODO: argumento que isso dá a solução certa

Abaixo está o mesmo exemplo do item a) com dias da semana. Para deixar
a visualização mais simples estamos colocando aqui apenas dois dias da
semana.

\[\begin{tikzpicture}[x=0.25\textwidth, scale=0.9,
    every edge/.style={
        draw,
        postaction={decorate,
                    decoration={markings,mark=at position 1 with {\arrow[line width = 0.5mm]{stealth}}}
                   }
        }
]
\vertex (fonte') at (0,3) [label=above:$\textit{s}$] {};
\vertex (fonte) at (-0.5,3) [label=above:$s'$] {};
\vertex (1) at (1, 4) [label=above:$1$] {};
\vertex (2) at (1, 2) [label=above:$2$] {};
\vertex (I1) at (2,5) [label=above:$I_1$] {};
\vertex (I2) at (2,3) [label=above:$I_2$] {};
\vertex (I3) at (2,1) [label=above:$I_3$] {};
\vertex (A) at (3,4) [label=above:$A$] {};
\vertex (B) at (3,2) [label=above:$B$] {};
\vertex (dreno) at (4,3) [label=above:$t$] {};
\path
(fonte) edge node [above] {$c/c$} (fonte')
(fonte') edge node [above] {$d_1/c$} (1)
(fonte') edge node [above] {$d_2/c$} (2)
(1) edge (I1)
(1) edge (I2)
(2) edge (I3)
(I1) edge (A)
(I1) edge (B)
(I2) edge (B)
(I3) edge (A)
(A) edge node [above] {$a/b$} (dreno)
(B) edge node [above] {$a/b$} (dreno)
;
\end{tikzpicture}\]

\subsection{Implementação}
\label{sec-3-4}

\subsubsection{Fluxo máximo}
\label{sec-3-4-1}

Vamos começar estudando o problema de encontrar o fluxo máximo de uma
rede $G$ em que $d_e = 0 \; \forall e \in E$ $f$. Vamos implementar aqui o
algoritmo de Ford-Fulkerson para resolver esse problema.

O algoritmo tem 2 partes:

\begin{enumerate}
\item Dado um caminho $P$ e partindo de um fluxo inicial $f$, obter um
novo fluxo $f'$ expandindo $f$ em $P$
\item Partindo do fluxo $f(e)$ = 0, expandir o fluxo enquanto for possível
\end{enumerate}


\begin{itemize}
\item Primeira parte:
\end{itemize}

O gargalo de um caminho é TODO: definir gargalo, explicar o código a seguir
Definimos aqui uma função que encontra o gargalo do caminho
\begin{minted}[]{python}
def encontra_gargalo(self, caminho):
    residuos = []
    for aresta in caminho:
        residuos.append(aresta.capacidade - self.fluxo[aresta])
    return min(residuos)
\end{minted}

Expandir o caminho é TODO: explicar o que é expandir o caminho,
\begin{minted}[]{python}
def expande_caminho(self, caminho):
    gargalo = self.encontra_gargalo(caminho)
    for aresta in caminho:
        self.fluxo[aresta] += gargalo
        self.fluxo[aresta.reversa] -= gargalo
\end{minted}

Com isso temos a parte 1 do algoritmo.

Para a parte 2, vamos precisar criar um fluxo $f$ com $f(e) = 0$ para
toda aresta $e$. Podemos fazer isso utilizando o seguinte método na
classe RedeDeFluxo():
\begin{minted}[]{python}
def cria_fluxo_inicial(self):
    for vertice, arestas in self.adj.iteritems():
        for aresta in arestas:
            self.fluxo[aresta] = 0
\end{minted}

\begin{verbatim}
None
\end{verbatim}

TODO: explicar porque precisamos desse método e como ele funciona
Retorna um caminho de fonte a dreno passando pelos vértices
em caminho
É uma DFS
\begin{minted}[]{python}
def encontra_caminho(self, fonte, dreno, caminho, visitados):
    if fonte == dreno:
        return caminho

    visitados.add(fonte)

    for aresta in self.encontra_arestas(fonte):
        residuo = aresta.capacidade - self.fluxo[aresta]
        if residuo > 0 and aresta.destino not in visitados:
            resp = self.encontra_caminho(aresta.destino,
                                         dreno,
                                         caminho + [aresta],
                                         visitados)
            # TODO: explicar essa parte
            if resp != None:
                return resp
\end{minted}

Com todas as funções auxiliares prontas, podemos finalmente definir a
função que encontra o fluxo máximo.

TODO: explicar o algoritmo de fluxo máximo
\begin{minted}[]{python}
def fluxo_maximo(self, fonte, dreno):
    self.cria_fluxo_inicial()

    caminho = self.encontra_caminho(fonte, dreno, [], set())
    while caminho is not None:
        self.expande_caminho(caminho)
        caminho = self.encontra_caminho(fonte, dreno, [], set())
    return self.valor_do_fluxo(fonte)
\end{minted}

\subsubsection{Fluxo válido com demandas não-nulas}
\label{sec-3-4-2}

O nosso objetivo é encontrar um fluxo válido $f$ para uma rede $G =
(V, E)$ no caso em que as demandas são positivas.

Vamos construir uma rede $G' = (V', E')$ com um valor associado $d$
tal que $d_e = 0 \; \forall e \in E'$ de tal forma que um fluxo válido
para $G$ existe se e somente se o valor do fluxo máximo em $G'$ é
$d$. Em caso afirmativo, podemos construir um fluxo válido $f$ para
$G$ rapidamente a partir de qualquer fluxo máximo $f'$ de $G'$.

Construimos $G'$ da seguinte forma:

\begin{itemize}
\item Criamos um vértice em $G'$ para cada vértice $G$
\item Adicionamos uma fonte adicional $F$ e um dreno adicional $D$ a $G'$
\item Definimos o saldo de cada vértice $v \in V$ como: \[
  \textrm{saldo}(v) = \sum_{e \text{ saindo de }v}d_e - \sum_{e \text{
  chegando em }v}d_e \]
\item Se $\mathrm{saldo}(v) > 0$ adicionamos uma aresta $(v, D,
  \mathrm{saldo}(v), 0)$ a $G'$
\item Se $\mathrm{saldo}(v) < 0$ adicionamos uma aresta $(F, v,
  -\mathrm{saldo}(v), 0)$ a $G'$
\item Para cada aresta $e = (\mathrm{origem, destino, capacidade,
  demanda}) \in E$, crie uma aresta $e' = (\mathrm{origem, destino,
  capacidade - demanda, 0})$ em $G'$
\end{itemize}

Codificando a construção acima:
\begin{minted}[]{python}
def cria_rede_com_demandas_nulas(G):
    G_ = RedeDeFluxo()
    G_.novo_vertice('F')
    G_.novo_vertice('D')
    d = 0

    for vertice, arestas in G.adj.iteritems():
        G_.novo_vertice(vertice)
        saldo = sum(e.demanda for e in arestas)
        if saldo > 0:
            G_.nova_aresta(vertice, 'D', saldo, 0)
            d += saldo
        elif saldo < 0:
            G_.nova_aresta('F', vertice, -saldo, 0)

    for arestas in G.adj.values():
        for a in arestas:
             if a.original:
                 G_.nova_aresta(a.origem,
                                a.destino,
                                a.capacidade - a.demanda,
                                0)
    return G_, d
\end{minted}

TODO: provar que soluções de um são também soluções do outro


\subsection{Complexidade}
\label{sec-3-5}

TODO: calcular a complexidade do algoritmo

\subsection{Rodando o algoritmo}
\label{sec-3-6}

\subsubsection{Item A}
\label{sec-3-6-1}
A seguinte tabela mostra a disponibilidade dos monitores nos horários
escolhidos pelo administrador:

\begin{center}
\begin{tabular}{lccccccccc}
 & Ana & Bia & Caio & Davi & Edu & Felipe & Gabi & Hugo & Isa\\
Seg 10h &  &  &  & x &  &  &  &  & \\
Seg 14h &  &  &  &  &  & x & x & x & x\\
Seg 21h & x &  &  & x &  &  &  &  & \\
Ter 10h & x & x &  & x &  &  &  &  & \\
Ter 16h &  &  & x &  &  &  &  &  & \\
Ter 20h &  &  &  &  &  &  & x &  & x\\
Qua 9h &  &  &  &  &  & x &  &  & \\
Qua 17h &  &  & x &  &  &  &  &  & \\
Qua 19h &  &  &  &  &  &  &  & x & \\
Qui 7h &  & x &  &  &  & x &  &  & \\
Qui 13h &  &  &  &  &  &  & x &  & \\
Qui 19h &  & x &  &  & x &  &  & x & \\
Sex 7h &  &  & x &  & x &  &  &  & \\
Sex 11h & x &  &  &  & x &  &  &  & x\\
Sex 21h &  &  & x &  &  & x &  &  & x\\
\end{tabular}
\end{center}
As outras regras para monitoria estão na tabela abaixo:

\begin{center}
\begin{tabular}{lr}
Min de horas por monitor & 1\\
Max de horas por monitor & 3\\
Horas de monitoria & 10\\
\end{tabular}
\end{center}

Podemos carregar as informações das tabelas para criar uma rede como
descrita em TODO: colocar a referencia certa.
\begin{minted}[]{python}
# Lendo a tabela de disponibilidade
intervalos = collections.OrderedDict()
monitores = horarios[0][1:]

for disponibilidade in horarios[1:]:
    intervalos[disponibilidade[0]] = []
    for i, slot in enumerate(disponibilidade[1:]):
        if slot != '':
            intervalos[disponibilidade[0]].append(monitores[i])
\end{minted}

Lendo a tabela de regras
\begin{minted}[]{python}
min_horas = regras[0][1]
max_horas = regras[1][1]
total_horas = regras[2][1]
\end{minted}

Criando uma rede para o problema com os dados fornecidos

\begin{minted}[]{python}
def cria_rede(intervalos, monitores, min_horas, max_horas, total_horas):
    G = RedeDeFluxo()
    G.novo_vertice('Fonte')
    G.novo_vertice('Dreno')
    G.nova_aresta('Dreno', 'Fonte', total_horas, total_horas)

    # Criando um vertice para cada monitor e ligando esse vertice ao dreno
    for monitor in monitores:
        G.novo_vertice(monitor)
        G.nova_aresta(monitor, 'Dreno', max_horas, min_horas)

    for intervalo, monitores_disponiveis in intervalos.iteritems():
        # Criando um vertice para cada intervalo e conectando a fonte a
        # cada um dos intervalos
        G.novo_vertice(intervalo)
        G.nova_aresta('Fonte', intervalo, 1, 0)

        # Conectando o intervalo a cada monitor disponivel nele
        for monitor in monitores_disponiveis:
            G.nova_aresta(intervalo, monitor, 1, 0)

    return G
\end{minted}

Agora é só rodar o algoritmo com o grafo obtido:
\begin{minted}[]{python}
G = cria_rede(intervalos, monitores, min_horas, max_horas, total_horas)
G_, d = cria_rede_com_demandas_nulas(G)
fluxo = G_.fluxo_maximo('F', 'D')
if fluxo == d:
    tabela_de_monitores = []
    for horario in intervalos:
        for w in G_.adj[horario]:
            if G_.fluxo[w] == 1:
                tabela_de_monitores.append([w.origem, w.destino])
    return tabela_de_monitores
else:
    return 'Impossivel'
\end{minted}

No final, obtemos ou 'Impossível' se não existir um horário compatível
ou uma tabela com um horário que atende a todas as restrições.

Para a tabela acima:

\subsubsection{Item b}
\label{sec-3-6-2}

No item b, além de todas as restrições do item a, há também a
restrição de mínimo de horas por dia da semana.

Vamos expressar a nova restrição com uma tabela:

\begin{center}
\begin{tabular}{lr}
Seg & 1\\
Ter & 1\\
Qua & 2\\
Qui & 1\\
Sex & 1\\
\end{tabular}
\end{center}

Parsear a nova tabela é simples:
\begin{minted}[]{python}
minimo_por_dia = {}
for dia in min_por_dia:
    minimo_por_dia[dia[0]] = dia[1]
\end{minted}

A única função que precisamos alterar do item a é a função
\verb~cria_rede~, que agora tem que lidar com a construção mencionada em TODO.

\begin{minted}[]{python}
def cria_rede(intervalos, monitores, min_horas,
              max_horas, total_horas, minimo_por_dia):
    G = RedeDeFluxo()
    G.novo_vertice('Fonte')
    G.novo_vertice('Dreno')
    G.nova_aresta('Dreno', 'Fonte', total_horas, total_horas)

    # Criando um vertice para cada monitor e ligando esse vertice ao dreno
    for monitor in monitores:
        G.novo_vertice(monitor)
        G.nova_aresta(monitor, 'Dreno', max_horas, min_horas)

    # Criando um vertice para cada dia e uma aresta da Fonte ao dia
    # com demanda igual ao minimo de horas de monitoria para aquele dia
    # e capacidade suficientemente grande (vamos usar o total de horas)
    dias = minimo_por_dia.keys()
    for dia in dias:
        G.novo_vertice(dia)
        G.nova_aresta('Fonte', dia, total_horas, minimo_por_dia[dia])

    for intervalo, monitores_disponiveis in intervalos.iteritems():
        # Encontrando o dia do intervalo
        for dia in dias:
            if intervalo.startswith(dia):
                dia_do_intervalo = dia

        # Criando um vertice para cada intervalo e conectando o dia do intervalo
        # a cada um dos intervalos
        G.novo_vertice(intervalo)
        G.nova_aresta(dia_do_intervalo, intervalo, 1, 0)

        # Conectando o intervalo a cada monitor disponivel nele
        for monitor in monitores_disponiveis:
            G.nova_aresta(intervalo, monitor, 1, 0)

    return G
\end{minted}

\begin{center}
\begin{tabular}{ll}
Seg 10h & Davi\\
Seg 14h & Isa\\
Seg 21h & Ana\\
Ter 10h & Bia\\
Ter 16h & Caio\\
Qua 9h & Felipe\\
Qua 17h & Caio\\
Qua 19h & Hugo\\
Qui 13h & Gabi\\
Sex 7h & Edu\\
\end{tabular}
\end{center}

\section{Exercício 4.5 (Tardos)}
\label{sec-4}

\subsection{Enunciado}
\label{sec-4-1}

Vamos considerar uma rua campestre longa e quieta, com casas
espalhadas bem esparsamente ao longo da mesma. (Podemos imaginar a
rua como um grande segmento de reta, com um extremo leste e um
extremo oeste.) Além disso, vamos assumir que, apesar do ambiente
bucólico, os residentes de todas essas casas são ávidos usuários de
telefonia celular.

Você quer colocar estações-base de celulares em certos pontos da
rodovia, de modo que toda casa esteja a no máximo quatro milhas de
uma das estações-base. Dê um algoritmo eficiente para alcançar esta
meta, usando o menor número possível de bases.

\section{Exercício 8.19 (Tardos)}
\label{sec-5}

\subsection{Enunciado}
\label{sec-5-1}

Um comboio de navios chega ao porto com um total de $n$ vasilhames
contendo tipos diferentes de materiais perigosos.
Na doca, estão $m$ caminhões, cada um com capacidade para até $k$
vasilhames.  Para cada um dos dois problemas, dê um algoritmo
polinomial ou prove NP-completude:


\begin{itemize}
\item Cada vasilhame só pode ser carregado com segurança em alguns
dos caminhões. Existe como estocar os $n$ vasilhames nos $m$
caminhões de modo que nenhum caminhão esteja sobrecarregado, e
todo vasilhame esteja num caminhão que o comporta com segurança?
\item Qualquer vasilhame pode ser colocado em qualquer caminhão,
mas alguns pares de vasilhames não podem ficar juntos num mesmo
caminhão. Existe como estocar os $n$ vasilhames nos $m$
caminhões de modo que nenhum caminhão esteja sobrecarregado e
que nenhum dos pares proibidos de vasilhames esteja no mesmo
caminhão?
\end{itemize}
% Emacs 24.4.1 (Org mode 8.2.10)
\end{document}
