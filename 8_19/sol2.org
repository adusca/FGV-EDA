#+TITLE:	Exercício 8.19 (Tardos)
#+AUTHOR:	Alice Duarte Scarpa, Bruno Lucian Costa
#+EMAIL:	alicescarpa@gmail.com, bruno.lucian.costa@gmail.com
#+DATE:		2015-06-23
#+OPTIONS: tex:t
#+OPTIONS: toc:nil
#+STARTUP: showall
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LaTeX_HEADER: \usemintedstyle{perldoc}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usetikzlibrary{decorations.markings}
#+LaTeX_HEADER: \tikzstyle{vertex}=[circle, draw, inner sep=0pt, minimum size=7pt]
#+LaTeX_HEADER: \newcommand{\vertex}{\node[vertex]}

* Enunciado

Um comboio de navios chega ao porto com um total de $n$ vasilhames
contendo tipos diferentes de materiais perigosos.
Na doca, estão $m$ caminhões, cada um com capacidade para até $k$
vasilhames.  Para cada um dos dois problemas, dê um algoritmo
polinomial ou prove NP-completude:


- Cada vasilhame só pode ser carregado com segurança em alguns
  dos caminhões. Existe como estocar os $n$ vasilhames nos $m$
  caminhões de modo que nenhum caminhão esteja sobrecarregado, e
  todo vasilhame esteja num caminhão que o comporta com segurança?

- Qualquer vasilhame pode ser colocado em qualquer caminhão,
  mas alguns pares de vasilhames não podem ficar juntos num mesmo
  caminhão. Existe como estocar os $n$ vasilhames nos $m$
  caminhões de modo que nenhum caminhão esteja sobrecarregado e
  que nenhum dos pares proibidos de vasilhames esteja no mesmo
  caminhão?

* Item a

Uma solução força-bruta para esse problema seria:

- Extenda a lista de vasilhames com vasilhames vazios, até que ela
  tenha tamanho  $mk$ (a capacidade total de todos os caminhões).
- Para cada uma das $(mk)!$ ordenações da lista acima, considere que
  os $k$ primeiros vão para o primeiro caminhão, os $k$ próximos para
  o segundo e assim até o final da lista. Se cada vasilhame estiver em
  um camihão que o comporta com segurança, retorne essa solução, se
  não, tente com uma nova ordem.

Esse algoritmo faz $(mk)!$ iterações do loop principal no pior caso, cada
iteração tem custo $mk$ para conferir se é uma solução válida. Isso dá
uma complexidade total de $O(mk(mk)!)$

Esse é um algoritmo super-exponencial para o problema, mas isso não
significa que o problema é NP-completo. Na verdade, como veremos a
seguir, esse problema não é NP-completo pois aceita uma solução
polinomial usando fluxos.

** Solução com fluxos

Podemos transformar esse problemas em um problema de encontrar o fluxo
máximo de um grafo usando a seguinte construção:

+ Criamos um vértice $s$ representando a fonte e um vértice $t$
  representando o dreno

+ Para cada vasilhame $v_i \in v_1, v_2, \ldots, v_n$ criamos um
  vértice $v_i$ e uma aresta $(s, v_i)$ capacidade 1

+ Para cada caminhão $C_i \in C_1, C_2, \ldots, C_m$ criamos um
  vértice $C_i$. Se o vasilhame $v_j$ puder ser transportado com
  segurança no caminhão $C_i$ criamos uma aresta $(v_j, C_i)$ de
  capacidade 1. Para cada caminhão criamos também uma aresta $(C_i, t)$
  de capacidade $k$.

Dessa forma, existe uma configuração possível de caminhões se e
somente se (TODO: provar) o fluxo máximo tem valor $m$.

Para a seguinte situação:
#+tblname: regras
| Capacidade     |  4 |
| Total de cam.  |  3 |
| Total de vas.  | 10 |


#+ATTR_LATEX: :align  r l
#+tblname: seguros
| Vasilhame | Cam. seguros |
|         1 | 1, 4         |
|         2 | 1, 2         |
|         3 | 3, 4         |
|         4 | 4            |
|         5 | 1, 2, 3, 4   |
|         6 | 1            |
|         7 | 3            |
|         8 | 1, 2, 3      |
|         9 | 2, 3         |
|        10 | 4            |



A construção seria como ilustrado na figura abaixo. Omitimos as
capacidades iguais a 1 para não poluir demais a imagem.

\[\begin{tikzpicture}[x=0.25\textwidth,
    every edge/.style={
        draw,
        postaction={decorate,
                    decoration={markings,mark=at position 1 with {\arrow[line width = 0.5mm]{stealth}}}
                   }
        }
]
\vertex (fonte) at (0,5) [label=above:$s$] {};
\vertex (v1) at (1,10) [label=above:$v_1$] {};
\vertex (v2) at (1,9) [label=above:$v_2$] {};
\vertex (v3) at (1,8) [label=above:$v_3$] {};
\vertex (v4) at (1,7) [label=above:$v_4$] {};
\vertex (v5) at (1,6) [label=above:$v_5$] {};
\vertex (v6) at (1,5) [label=above:$v_6$] {};
\vertex (v7) at (1,4) [label=above:$v_7$] {};
\vertex (v8) at (1,3) [label=above:$v_8$] {};
\vertex (v9) at (1,2) [label=above:$v_9$] {};
\vertex (v10) at (1,1) [label=above:$v_{10}$] {};
\vertex (C1) at (2.5,10) [label=above:$C_1$] {};
\vertex (C2) at (2.5,7) [label=above:$C_2$] {};
\vertex (C3) at (2.5,4) [label=above:$C_3$] {};
\vertex (C4) at (2.5,1) [label=above:$C_4$] {};
\vertex (dreno) at (3.5,5) [label=above:$t$] {};
\path
(fonte) edge (v1)
(fonte) edge (v2)
(fonte) edge (v3)
(fonte) edge (v4)
(fonte) edge (v5)
(fonte) edge (v6)
(fonte) edge (v7)
(fonte) edge (v8)
(fonte) edge (v9)
(fonte) edge (v10)
(v1) edge (C1)
(v1) edge (C4)
(v2) edge (C1)
(v2) edge (C2)
(v3) edge (C3)
(v3) edge (C4)
(v4) edge (C4)
(v5) edge (C1)
(v5) edge (C2)
(v5) edge (C3)
(v5) edge (C4)
(v6) edge (C1)
(v7) edge (C3)
(v8) edge (C1)
(v8) edge (C2)
(v8) edge (C3)
(v9) edge (C2)
(v9) edge (C3)
(v10) edge (C4)
(C1) edge node [above] {$4$} (dreno)
(C2) edge node [above] {$4$} (dreno)
(C3) edge node [above] {$4$} (dreno)
(C4) edge node [above] {$4$} (dreno)
;
\end{tikzpicture}\]

*** Implementação

Primeiramente, precisamos ser capazes de ler a tabela acima para
passar os valores para o nosso algoritmo.
#+NAME: processa_regras
#+BEGIN_SRC python
capacidade_por_caminhao = regras[0][1]
total_de_vasilhames = regras[2][1]
#+END_SRC

#+NAME: processa_seguros
#+BEGIN_SRC python
vasilhames = collections.OrderedDict()
caminhoes = []
for line in seguros[1:]:
    # Nomeando os vasilhames
    vasilhame = 'v_%s' % line[0]
    vasilhames[vasilhame] = []
    for caminhao in str(line[1]).split(','):
        nome = 'C_%s' % caminhao.strip()
        vasilhames[vasilhame].append(nome)
        if nome not in caminhoes:
            caminhoes.append(nome)
#+END_SRC

Vamos usar a classe RedeDeFluxo, que definimos para a questão 7.28.

#+NAME: cria_grafo
#+BEGIN_SRC python
def cria_grafo(vasilhames, caminhoes, capacidade_por_caminhao):
    G = RedeDeFluxo()
    G.novo_vertice('Fonte')
    G.novo_vertice('Dreno')

    # Criando um vertice para cada caminhao e ligando esse vertice ao dreno
    for caminhao in caminhoes:
        G.novo_vertice(caminhao)
        G.nova_aresta(caminhao, 'Dreno', capacidade_por_caminhao, 0)

    for vasilhame, caminhoes in vasilhames.iteritems():
        # Criando um vertice para cada vasilhame e conectando a fonte a
        # cada um dos vasilhames
        G.novo_vertice(vasilhame)
        G.nova_aresta('Fonte', vasilhame, 1, 0)

        # Conectando o vasilhame a cada caminhao que pode transporta-lo
        for caminhao in caminhoes:
            G.nova_aresta(vasilhame, caminhao, 1, 0)

    return G
#+END_SRC

Como nesse problema as demandas já são 0, podemos aplicar
Ford-Fulkerson diretamente, usando a mesma implementação que fizemos
para o exercício 7.28.

Podemos então rodar Ford-Fulkerson e ver se o fluxo máximo encontrado
é igual ao total de vasilhames. Se for, isso significa que o problema
tem solução que vamos retornar. Caso contrário não existe arranjo possível.
#+NAME: rodando
#+BEGIN_SRC python
G = cria_grafo(vasilhames, caminhoes, capacidade_por_caminhao)
fluxo = G.fluxo_maximo('Fonte', 'Dreno')
if fluxo == total_de_vasilhames:
    tabela_de_vasilhames = []
    for vasilhame in vasilhames:
        for w in G.adj[vasilhame]:
            if G.fluxo[w] == 1:
                tabela_de_vasilhames.append([w.origem, w.destino])
    return tabela_de_vasilhames
else:
    return 'Impossivel'
#+END_SRC

#+NAME: ford_fulkeson
#+BEGIN_SRC python :exports none
    def __init__(self, origem, destino, capacidade, demanda):
        self.origem = origem
        self.destino = destino
        self.capacidade = capacidade
        self.demanda = demanda
        self.reversa = None
        self.original = True

class RedeDeFluxo():
    def __init__(self):
        self.adj = collections.OrderedDict()
        self.fluxo = {}

    def novo_vertice(self, v):
        self.adj[v] = []

    def nova_aresta(self, origem, destino, capacidade, demanda):
        aresta = Aresta(origem, destino, capacidade, demanda)
        self.adj[origem].append(aresta)

        # Criando a aresta reversa
        aresta_reversa = Aresta(destino, origem, 0, -demanda)
        self.adj[destino].append(aresta_reversa)
        aresta_reversa.original = False

        # Marcando aresta e aresta_reversa como reversas uma da outra
        aresta.reversa = aresta_reversa
        aresta_reversa.reversa = aresta

    def novo_fluxo(self, e, f):
        self.fluxo[e] = f

    def encontra_arestas(self, v):
        return self.adj[v]

    def valor_do_fluxo(self, fonte):
        valor = 0
        for aresta in self.encontra_arestas(fonte):
            valor += self.fluxo[aresta]
        return valor

    def encontra_gargalo(self, caminho):
        residuos = []
        for aresta in caminho:
            residuos.append(aresta.capacidade - self.fluxo[aresta])
        return min(residuos)

    def expande_caminho(self, caminho):
        gargalo = self.encontra_gargalo(caminho)
        for aresta in caminho:
            self.fluxo[aresta] += gargalo
            self.fluxo[aresta.reversa] -= gargalo

    def cria_fluxo_inicial(self):
        for vertice, arestas in self.adj.iteritems():
            for aresta in arestas:
                self.fluxo[aresta] = 0

    def encontra_caminho(self, fonte, dreno, caminho, visitados):
        if fonte == dreno:
            return caminho

        visitados.add(fonte)

        for aresta in self.encontra_arestas(fonte):
            residuo = aresta.capacidade - self.fluxo[aresta]
            if residuo > 0 and aresta.destino not in visitados:
                resp = self.encontra_caminho(aresta.destino,
                                             dreno,
                                             caminho + [aresta],
                                             visitados)
                if resp != None:
                    return resp

    def fluxo_maximo(self, fonte, dreno):
        self.cria_fluxo_inicial()

        caminho = self.encontra_caminho(fonte, dreno, [], set())
        while caminho is not None:
            self.expande_caminho(caminho)
            caminho = self.encontra_caminho(fonte, dreno, [], set())
        return self.valor_do_fluxo(fonte)

#+END_SRC

#+BEGIN_SRC python :tangle solucao_a.py :noweb yes :exports results :var seguros=seguros regras=regras
# coding: utf-8
import collections

<<ford_fulkeson>>

<<processa_regras>>

<<processa_seguros>>

<<cria_grafo>>

<<rodando>>
#+END_SRC

#+RESULTS:
| v_1  | C_4 |
| v_2  | C_1 |
| v_3  | C_3 |
| v_4  | C_4 |
| v_5  | C_1 |
| v_6  | C_1 |
| v_7  | C_3 |
| v_8  | C_1 |
| v_9  | C_2 |
| v_10 | C_4 |



*** Complexidade

* Item b
